[[_git_submodules]]
=== 子模块

经常有一种情况是你在一个项目中工作，你需将另一个项目包含在其中使用它。
也许是第三方开发的库或者是你单独开发的用在多个父项目中。
这些场景中引发了一个常见的问题；你想要将两个项目认为是独立的，还想要在一个中使用另一个。

这有一个例子。
假设你正在开发一个网站然后创建了 Atom 订阅。
你决定使用一个库，而不是写你自己的 Atom 生成代码。
你可能不得不通过 CPAN 安装或 Ruby gem 来包含共享库中的代码，或者将源代码直接拷贝到你自己的项目中。
包含这个库的问题是不管用什么方式都很难定制库并且部署它更难，因为你需要确保每一个客户端都必须有那个库。
将代码拷贝到你自己的项目的问题是任何你做的自定义修改使合并上游的改动变得很困难。

Git 通过子模块来解决这个问题。
子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。
这允许你克隆另一个仓库到你的项目内并保持你的提交独立。

[[_starting_submodules]]
==== 开始使用子模块

我们将要演示如何在一个被分成一个主项目与几个子项目的项目上开发。

让我们通过添加已存在的 Git 仓库作为我们正在工作仓库的子模块开始。为了添加一个新的子模块你可以使用一个有你想要跟踪项目的 URL 的 `git submodule add` 命令。在本例中，我们将会添加一个称作 ``DbConnector'' 的库。

[source,console]
----
$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 ``DbConnector''。如果你想要放到其他地方你可以在命令结尾添加一个不同的路径。

如果这时你运行 `git status`，你会注意到几件事。

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector
----

首先你应当注意到新的 `.gitmodules` 文件。
这是一个配置文件保存项目的 URL 与你已经将其拉入的本地目录之间的映射：

[source,console]
----
$ cat .gitmodules
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
----

如果你有多个子模块，在这个文件中你会有多条记录。
要重点注意是的这个文件与你的其他文件一样被版本控制着，就像你的 `.gitignore` 文件。
它会与你的项目的其他部分一同被推送与拉取。
这就是克隆这个项目的其他人知道去哪里获得子模块的原因。

[NOTE]
=====
因为 .gitmodules 文件中的 URL 会是其他人首先尝试克隆/拉取的地方，确保尽可能使用一个他们可以访问的 URL。例如，如果其他人从一个 URL 拉取而你推送到一个不同的 URL，使用其他人可以访问的 URL。为了你自己使用你可以通过 `git config submodule.DbConnector.url PRIVATE_URL` 在本地覆盖这个选项。
=====

在 `git status` 输出中列出的另一个是项目文件夹记录。
如果你运行 `git diff`，你会看到类似下面的信息：

[source,console]
----
$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
----

尽管 `DbConnector` 是你的工作目录中的子目录，Git 会将它看作为一个子模块，并且当你不在那个目录中时并不会跟踪它的内容。
相反，Git 将它看作是那个仓库中的一个特殊提交。

如果你想要一个漂亮点的差异输出，你可以传递 `--submodule` 选项给 `git diff`。

[source,console]
----
$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)
----

当你提交时，你会看到类似下面的信息：

[source,console]
----
$ git commit -am 'added DbConnector module'
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector
----

注意 DbConnector 记录的 `160000` 模式。
这是 Git 中的一种特殊模式，本质上意味着你将一次提交记录为一个目录记录而不是一个子目录或者一个文件。

[[_cloning_submodules]]
==== 克隆含有子模块的项目

这里我们将会克隆一个含有子模块的项目。
当你克隆这样的项目时，默认情况下你会获得包含子模块的目录，但是其中还没有任何文件：

[source,console]
----
$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$
----

`DbConnector` 目录在那儿，但是是空的。
你必须运行两个命令：`git submodule init` 来初始化你的本地配置文件，`git submodule update` 从那个项目中抓取所有数据并检出父项目中列出的合适的提交。

[source,console]
----
$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

现在你的 `DbConnector` 子目录是你之前提交时的相同状态了。

然而有另外一种简单一点儿的方式来做这件事。如果你传递 `--recursive` 给 `git clone` 命令，它会自动初始化并更新仓库中的每一个子模块。

[source,console]
----
$ git clone --recursive https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'
----

==== 在有子模块的项目上工作

现在我们有一份子模块在其中的项目拷贝，我们将会同时在主项目与子模块项目上与我们的队员协作。

===== 拉入上游修改

在项目中使用子模块最简单的模型是你只会消费子项目并想要不定期地获得更新，但是在你的检出中却不更改任何信息。

如果你想要在子模块中查看新工作，你可以进入到目录中并运行 `git fetch` 与 `git merge` 上游分支来更新本地代码。

[source,console]
----
$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -> origin/master
Scotts-MacBook-Pro-3:DbConnector schacon$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)
----

现在如果你返回到主项目并运行 `git diff --submodule` 你会看到子模块被更新了与获得了哪些提交添加进来的列表。如果你不想要在你每次运行 `git diff` 时输入类型 `--submodle`，你可以通过设置 `diff.submodule` 选项为 ``log'' 将其作为默认行为。

[source,console]
----
$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  > more efficient db routine
  > better connection routine
----

如果这时候你提交那么你会将子模块锁定为其他人更新时的新代码。

如果你不想要手动地在子目录中抓取与合并，也有一种轻松的方式可以这样做。如果你运行 `git submodule update --remote`，Git 将会进入你的子模块然后为你抓取并更新。

[source,console]
----
$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -> origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'
----

这个命令默认情况下会假定你想要更新并检出子模块仓库的 `master` 分支。然而，你也可以设置为你想要的其他分支。例如，你想要 DbConnector 子模块跟踪仓库的 ``stable'' 分支，你即可以在你的 `.gitmodules` 文件（这样其他人也可以跟踪它）设定，也可以只在你本地的 `.git/config` 文件中设定。让我们看看在 `.gitmodules` 文件中设定：

[source,console]
----
$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -> origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'
----

如果你不用 `-f .gitmodules` 选项那么它只会为你做修改，但是在仓库中保留跟踪信息更有意义一些因为其他人也可以这样做。

当我们在这时候运行 `git status`，Git 会显示我们在子模块中有 ``新提交''。

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")
----

如果你设置了配置选项 `status.submodulesummary`，Git 也会显示你的子模块的改动摘要：

[source,console]
----
$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  > catch non-null terminated lines
----

在这时候如果你运行 `git diff` 我们可以同时看到我们修改了 `.gitmodules` 文件，也有几个我们提取下来的提交准备提交到我们的子模块项目中。

[source,console]
----
$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

这非常酷因我们我可以真实地看到我们将要提交到子模块中的提交的日志。一旦提交，你也可以通过运行 `git log -p` 看到这个信息。

[source,console]
----
$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon <schacon@gmail.com>
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  > catch non-null terminated lines
  > more robust error handling
  > more efficient db routine
  > better connection routine
----

当你运行 `git submodule update --remote` 时 Git 默认情况下会尝试更新 **所有** 你的子模块，所以如果你有很多子模块的话，你可能会传递你想要更新的子模块的名字。

===== 在子模块上工作

很有可能你正在使用子模块，你这样做是因为你真的想要在子模块上的代码上工作的同时在主项目上的代码工作（或者交叉着几个子模块）。否则你很有可能会使用一个简单的依赖管理系统（如 Maven 或 Rubygems）来替代。

所以现在我们将通过一个例子演示同时在子模块与主项目中做修改，并且同时提交与发布那些修改。

到目前为止，当我们运行 `git submodule update` 从子模块仓库中抓取修改时，Git 将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 ``脱离的 HEAD'' 的状态。这意味着没有本地工作分支（例如 ``master''）跟踪改动。所以任何你做的改动都不会被跟踪。

为了将你的子模块设置地更轻松地进入与工作，你需要做两件事。你需要进入每一个子模块然后检出一个工作的分支。如果你做了改动你需要告诉怎么做然后 `git submodule update --remote` 拉入上游的新工作。选项是你可以合并它们到你的本地工作，或者你可以尝试变基你的工作到新的改动之上。

首先，让我们进入我们的子模块目录然后检出一个分支。

[source,console]
----
$ git checkout stable
Switched to branch 'stable'
----

让我们尝试用 ``merge'' 选项。为了手工指定它，我们可以仅仅添加 `--merge` 选项给我们的 `update` 调用。这里我们将会看到在服务器上的这个子模块有一个改动并且它被合并了进来。

[source,console]
----
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -> origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'
----

如果我们进入 DbConnector 目录，我们可以发现新的改动已经合并入我们的本地 `stable` 分支。现在让我们看看对库做一些我们自己本地的改动而同时其他人推送另外一个修改到上游时会发生什么。

[source,console]
----
$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)
----

现在如果我们更新我们的子模块，我们可以看到当我们做了本地改动时上游也有一个改动，我们需要包含它。

[source,console]
----
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

如果你忘记 `--rebase` 或 `--merge`，Git 将会更新子模块为服务器上的状态并且会将你的项目重置为一个脱离的 HEAD 状态。

[source,console]
----
$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'
----

如果这发生了，不要担心，你可以简单地回到目录中再次检出你的分支（还包含着你的工作的分支）然后手动地合并或变基 `origin/stable` （或任何一个你想要的远程分支）。

在你的子模块中如果你没有提交你的改动那么你运行一个子模块更新将会出现问题，Git 会抓取改动但是不会覆盖你的子模块目录中未保存的工作。

[source,console]
----
$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -> origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

如果你做了一些与上游改动冲突的改动，当你运行更新时 Git 会让你知道。

[source,console]
----
$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'
----

你可以进入子模块目录中然后就像你平常一样修复冲突。

[[_publishing_submodules]]
===== 发布子模块改动

现在在我们的子模块目录里有一些改动。其中有一些是我们通过更新从上游引入的而另一些是本地生成的，因为我们还没有推送它们所有对任何其他人都不可用。

[source,console]
----
$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  > Merge from origin/stable
  > updated setup script
  > unicode support
  > remove unnecessary method
  > add new option for conn pooling
----

如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦，因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。

为了确保这不会发生，你可以让 Git 在你推送到主项目前检查所有你的子模块是否已推送。`git push` 命令接受可以设置为 ``check'' 或 ``on-demand'' 的 `--recurse-submodules` 参数。如果任何提交的子模块改动没有推送那么 ``check'' 选项会使 `push` 操作直接失败。

[source,console]
----
$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.
----

如你所见，它也给我们了关于接下来如何做的一些有用的建议。最简单的选项是进入每一个子模块中然后手动推送到远程仓库来确保它们是可以被外部访问到的，然后再次尝试这次推送。

另一个选项是使用 ``on-demand'' 值，将会为你尝试这样做。

[source,console]
----
$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -> stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -> master
----

如你所见，Git 进入到 DbConnector 模块中然后在推送主项目前推送了它。如果那个子模块因为某些原因推送失败，主项目推送也会失败。

===== 合并子模块改动

如果你与其他人在同一时间改动了一个子模块引用，你可能会遇到一些问题。那就是，如果子模块的历史已经分叉并且在父项目中分别提交到了分叉的分支上，它会需要你一些工作来修复。

如果一个提交是另一个的直接祖先（一个快进式合并），那么 Git 将会简单地选择之后的合并，所以那工作地很好。

然而，Git 甚至不会为你尝试一个普通合并。如果子模块提交分叉并且需要合并，你会得到类似下面的信息：

[source,console]
----
$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -> origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

所以本质上这里发生的是 Git 指出在子模块历史中的两个分支记录点已经是分叉的并且需要合并。它将其解释为 ``merge following commits not found''，有点令人困惑但是我们将会解释一点儿为什么是那样。

为了解决问题，你需要指出子模块应该在什么状态。奇怪的是，Git 并不会真地给你很多信息来帮你摆脱困境，甚至没有两边历史的提交 SHA 值。幸运的是，它很容易指出来。如果你运行 `git diff` 你会得到记录在你尝试合并的两个分支的提交的 SHA 值。

[source,console]
----
$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
----

所以，在本例中，`eb41d76` 是我们子模块中 **我们** 有的提交而 `c771610` 是上游有的提交。如果我们进入子模块目录中，它应该已经在 `eb41d76` 因为合并并没有触碰它。无论任何原因如果不是的话，你可以简单地创建并检出一个指向它的分支。

重要的是来自另一边的提交的 SHA 值。这是你将要合并入并解决的。你既可以仅尝试直接通过 SHA 合并，也可以为它创建一个分支然后尝试合并。我们建议后者，哪怕只是为了一个更漂亮的合并提交信息。

所以，我们将会入进我们的子模块目录，基于 `git diff` 的第二个 SHA 创建一个分支然后手动合并。

[source,console]
----
$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610
(DbConnector) $ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.
----

我们在这得到了一个实际的合并冲突，所以如果我们解决并提交它，那么我们可以简单地通过结果来更新主项目。

[source,console]
----
$ vim src/main.c <1>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <2>
$ git diff <3>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <4>

$ git commit -m "Merge Tom's Changes" <5>
[master 10d2c60] Merge Tom's Changes
----

<1> 首先我们解决冲突
<2> 然后我们返回到主项目目录中
<3> 我们再次检查 SHA 值
<4> 解决冲突的子模块记录
<5> 提交我们的合并

它可能有一点困惑，但是它真的不是特别难。

有意思的是，有另一个 Git 处理的例子。
如果在子模块目录中存在着一个包含在历史中的 **两边** 提交的合并提交，Git 会向你建议它为一个可行的解决方案。它看到在子模块项目的某一点，有人合并了包含有这两次提交的分支，所以你可能想要那个。

这就是为什么前面的错误信息是 ``merge following commits not found''，因为它不能 *这样* 做。它让人困惑是因为谁会期待它 **尝试** 这样做？

如果它找到了一个可以接受的合并提交，你会看到类似下面的信息：

[source,console]
----
$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: > merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.
----

它建议你做的是更新索引就像你运行了 `git add` 一样，将会清除冲突，然后提交。然而你可能不应该这样做。你可以轻松地进入子模块目录，查看差异是什么，快进到这次提交，恰当地测试，然后提交它。

[source,console]
----
$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forwarded to a common submodule child'
----

这完成了同一件事，但是最少这种方式你可以验证是否有效，当你完成时在你的子模块目录中有你的代码。


==== 子模块技巧

你可以做几件事情使与子模块工作轻松一点儿。

===== 子模块遍历

有一个 `foreach` 子模块命令可以在每一个子模块运行任意命令。如果你有很多子模块在同一个项目内这真的很有帮助。

例如，假设我们想要开始一个新功能或做一个错误修复并且我们在几个子模块中工作。我们可以轻松地在所有的子模块中储藏所有的工作。

[source,console]
----
$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable
----

然后我们可以创建一个新分支并在所有子模块中切换过去。

[source,console]
----
$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'
----

你明白了。一个真的很有用的事情是你可以生成一个主项目与所有子项目的改动的统一差异。

[source,console]
----
$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&url, len, NULL, &out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;
----

这里我们看到我们在子模块中定义了一个函数并在主项目中调用它。这是一个很显然的简化例子，但是希望它能给你一些如何将其变得有用的想法。

===== 有用的别名

你可能想要为这些命令中的一些设置一些别名，因为它们可能会非常长而你又不能设置选项作为它们的默认选项。我们在 [[_git_aliases]] 介绍了设置 Git 别名，但是如果你计划在 Git 中大量使用子模块的话这里有一些你可能想要设置的别名的例子。

[source,console]
----
$ git config alias.sdiff '!'"git diff && git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'
----

这样当你想要更新你的子模块时你可以简单地运行 `git supdate`，或 `git spush` 检查子模块依赖后推送。

==== 子模块的问题

然而使用子模块并不是没有小问题。

例如在有子模块的项目中切换分支可能会麻烦。
如果你创建一个新分支，在那儿添加一个子模块，然后切换到没有那个子模块的分支时，你还会有一个未跟踪目录的子模块目录。

[source,console]
----
$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'adding crypto library'
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)
----

移除那个目录并不困难，但是有一个目录在那儿会让人有一点困惑。如果你移除它然后切换回有那个子模块的分支，你需要运行 `submodule update --init` 来重新弹出它。

[source,console]
----
$ git clean -fdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src
----

再一次，并不是真的很困难，但是它会让人有一点困惑。

另一个主要的警告是许多人遇到了从子目录转换为子模块的问题。
如果在你的项目中你已经跟踪了文件然后你想要将它们移动到一个子模块中，你必须非常小心否则 Git 会对你生气。
假设在你的项目里有一些文件在子目录中，你想要将其转换为一个子模块。
如果你删除子目录然后运行 `submodule add`，Git 会朝你大喊：

[source,console]
----
$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index
----

你必须要先取消暂存 `CryptoLibrary` 目录。
然后你才可以添加子模块：

[source,console]
----
$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
----

现在假设你在一个分支下做的那些。
如果你尝试切换回一个在实际树中那些文件还存在而不是子模块的分支 - 你会得到这个错误：

[source,console]
----
$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting
----

你可以通过 `check -f` 来强制它切换，但是要小心如果你在那儿有未保存的修改因为通过那个命令它们会被覆盖掉。

[source,console]
----
$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
----

然后，当你切换回来，你因为某些原因得到一个空的 `CryptoLibrary` 目录并且 `git submodule update` 也无法修复它。你需要进入到你的子模块目录中然后运行 `git checkout .` 来找回所有你的文件。你可以为多个子模块通过 `submodule foreach` 脚本来运行它。

要特别注意的是近来子模块将它们的所有 Git 数据保存在顶部项目的 `.git` 目录中，所以不像旧版本的 Git，摧毁一个子模块目录并不会丢失你有的任何提交或分支。

通过这些工具，子模块可以是同时在几个相关但是分离的项目上开发的相当简单与有效的方法。
