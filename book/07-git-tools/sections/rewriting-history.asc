[[_rewriting_history]]
=== 重写历史

许多时候，当使用 Git 工作时，你可能会因为某些原因想要修正你的提交历史。
关于 Git 最棒的一件事情是它允许你在最后时刻做决定。
你可以在你将暂存区内容提交前决定哪些文件进入提交，你也可以通过 stash 命令来决定不与某些内容工作，你可以重写已经发生的提交就像它们以另一种方式发生的一样。
这可能包括改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分，或完全地移除提交 - 在你将你的作共享给其他人之前。

在本节中，你可以学习如何完成这些非常有用的工作，这样可以在你将其共享给其他人前使你的提交历史看起来像你想要的方式。

[[_git_amend]]
==== 修改最后一次提交

修改你的最后一次提交可能是你会做的最常见的修改历史。
你会经常需要对你的最后提交做两个基本的事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。

如果你只想要修改你最后的提交信息，它很简单：

[source,console]
----
$ git commit --amend
----

它会让你进入你的文本编辑器，里面有你的最后提交信息，已经准备好让你修改信息。
当你保存并关闭编辑器后，编辑器会将信息写入到一个新的提交中并使其成为你的新的最后提交。

如果你已经提交然后你想要通过添加或修改文件来修改你提交的快照，可能是因为你最初提交时忘记添加一个新创建的文件，这个过程做起来基本上差不多。
通过修改文件然后运行 `git add` 或 `git rm` 一个已追踪的文件，随后运行 `git commit --amed` 拿走你当前的暂存区域并使其做为新提交的快照。

你需要小心这项技巧因为修正修改了提交的 SHA-1 校验和。
它类似于一个小的变基 - 如果你已经推送了最后一次提交就不要修正它。

[[_changing_multiple]]
==== 修改多个提交信息

为了改变在你提交历史中较远的提交，你必须使用更复杂的工具。
Git 没有一个改变历史工具，但是你可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。
通过交互式变基工具，你可以在任何你想要修改的提交后停止，然后修改信息、添加文件或做任何你想做的事情。
你可以通过增加 `-i` 选项给 `git rebase` 来交互式地运行变基。
你必须指定你想要重写多久远的历史，通过告诉命令将要变基到的提交。

例如，如果你想要修改最后三次提交信息，或者那组提交中的任一一个提交信息，你将你想要修改的最后一次提交的父提交作为参数传递给 `git rebase -i`，它是 `HEAD~2^` 或 `HEAD~3`。
记住 `~3` 可能比较容易因为你正尝试修改最后三次提交；但是注意你实际上指定了以前的四次提交，你想要修改提交的父提交：

[source,console]
----
$ git rebase -i HEAD~3
----

再次记住这是一个变基命令 - 在 `HEAD~3..HEAD` 范围内的每一个提交都会被重写，无论你是否修改信息。
不要包括任何你已经推送到中央服务器的提交 - 这样做会让其他人困惑因为提供了相同修改的一个替代版本。

运行这个命令会在你的文本编辑器上给你一个提交的列表，看起来像下面这样：

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

需要重点注意的是相对于你正常使用的 `log` 命令，这些提交显示的顺序是相反的。
如果你运行一个 `log`，你会看到类似这样的东西：

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

注意其中的反序显示。
交互式变基给你一个它将会运行的脚本。
它将会从你在命令行中指定的提交（`HEAD~3`）开始，然后从下到下的依然重演每一个提交引入的修改。
它将最旧的列在上面，而不是最新的，因为那会是第一个将要重演的。

你需要修改脚本这样它才可以在你想要修改的提交前停下。
为了这样做，将你想要脚本停下后的每一个提交前的单词 `pick' 修改为单词 `edit'。
例如，只想修改第三次提交信息，你可以像下面这样修改文件：

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

当你保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你扔回命令行并提示你以下信息：

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
----

这些指令精确地告诉你该做什么。
输入

[source,console]
----
$ git commit --amend
----

修改提交信息，然后退出编辑器。
然后，运行

[source,console]
----
$ git rebase --continue
----

这个命令将会自动地应用另外两个提交，然后你就完成了。
如果你修改 pick 为 edit 不止一行的话，你需要在每一个你修改为 edit 的提交上重复这些步骤。
每一次，Git 将会停止，让你修正提交，然后继续直到你完成。

==== 重新排序提交

你也可以使用交互式变基来重新排序或完全移除提交。
如果你想要移除 ``added cat-file'' 提交然后修改另外两个提交引入的顺序，你可以将变基脚本从这样：

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

改为这样：


[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

当你保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 `310154e` 然后应用 `f7f3f6d`，最后停止。
你事实修改了那些提交的顺序并完全地移除了 ``added cat-file'' 提交。

[[_squashing]]
==== 压缩提交

通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。
在变基信息中脚本给出了有用的指令：

[source,console]
----
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

如果，你指定 ``squash'' 而不是 ``pick'' 或 ``edit''，Git 应用两者的修改并使你合并提交信息在一起。
所以，如果你想要这三次提交变为一个提交，你可以这样修改你的脚本：

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

当你保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

当你保存后，你会得到一个将之前所有的三次提交的修改引入的单个提交。

==== 拆分提交

拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成。
例如，假设你想要拆分三次提交的中间那次提交。
你想要将它拆分为两次提交：第一个  ``updated README formatting''，第二个 ``added blame'' 来代替原来的 ``updated README formatting and added blame''。
你可以通过修改 `rebase -i` 的脚本来做到这点，将你要拆分的提交的指令修改为 ``edit''：

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

然后，当脚本将你进入到命令行时，你重置那个提交，拿到被重置的修改，从中创建几次提交。
当你保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（`f7f3f6d`），应用第二个提交（`310154e`），然后让你进入命令行。
那里，你可以通过 `git reset HEAD^` 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件未暂存。
现在你可以暂存并提交文件直到你有几个提交，然后当你完成时运行 `git rebase --continue`：

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git 在脚本中应用最后一次提交（`a5f4a0d`），你的历史看起来像这样：

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

再一次，这些改动了所有在你列表中提交的 SHA 校验和，所以要确保列表中的提交还没有推送到共享仓库中。

==== 核武器选项：filter-branch

有另一个历史改写的选项，如果你想要通过脚本的方式改写大量的提交你可以使用它 - 例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。
这个命令是 `filter-branch`，它可以改写你的历史中大量的提交，所以你不应当使用它，除非你的项目还没有公开并且其他人没有基于你要改写的工作的提交做的工作。
然而，它可以很有用。
你将会学习到几个常用的用途，这样你就得到了它适合使用地方的想法。

[[_removing_file_every_commit]]
===== 从每一个提交移除一个文件

这经常发生。
有人粗心地通过 `git add .` 提交了一个巨大的二进制文件，你想要从所有地方删除它。
可能你偶然地提交了一个包括一个密码的文件，你想要开源你的项目。
`filter-branch` 是一个你可能会用来擦洗整个提交历史的工具。
为了从你的整个提交历史中移除一个叫做 passwords.txt 的文件，你可以使用 `--tree-filter` 选项给 `filter-branch`：

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

`--tree-filter` 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。
这本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。
如果你想要移除所有偶然提交的编辑器备份文件，你可以运行类似 `git filter-branch --tree-filter 'rm -f *~' HEAD` 的命令。

最后你将可以看到 Git 重写树与提交然后移动分支指针。
通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是你真正想要的，你可以硬重置你的 master 分支。
为了让 `filter-branch` 在所有你的分支上运行，你可以给命令传递 `--all` 选项。

===== 使一个子目录做为新的根目录

假设你已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。
如果你想要让 `trunk` 子目录作为每一个提交的新的项目根目录，`filter-branch` 也可以帮助你那么做：

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

现在你的新项目根目录是 `trunk` 子目录了。
Git 会自动移除所有不影响子目录的提交。

===== 全局修改邮箱地址

另一个常见的情形是在你开始工作时你忘记运行 `git config` 来设置你的名字与邮箱地址，或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。
任何情形下，你也可以通过 `filter-branch` 来一次性修改多个提交中的邮箱地址。
你需要小心的是只修改你自己的邮箱地址，所以你使用 `--commit-filter`：

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

这会遍历与重写每一个提交来包含你的新邮箱地址。
因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA 校验和，而不仅仅只是那些匹配邮箱地址的提交。
