[[_git_reset]]
=== 重置揭密

在继续到更特定的工具前，让我们讨论一下 `reset` 与 `checkout`。
这些命令是当你初次遇到它们时两个最让人困惑的 Git 部分。
它们做很多事情，看起来真正地理解与合适地运用它们是没有希望的。
因为这点，我们推荐一个简单的比喻。

==== 三棵树

理解 `reset` 与 `checkout` 的最简单方式就是通过 Git 的核心，三棵不同树的内容管理器。
``树'' 在我们这里真正的意思是 ``文件的集合''，而不是特指数据结构。
（有少数几个例子显示索引并不像一个树，但是现在我们目的是用简单的方式思考它。）

Git 像一个系统在它的正常操作中管理与操纵三棵树：

[cols="1,2",options="header"]
|================================
| 树                | 角色
| HEAD              | 最后一次提交快照，下一个父结点
| Index             | 计划的下一次的提交快照
| Working Directory | 沙箱
|================================

===== HEAD

HEAD 是指向当前分支引用的指针，是一个每次都指向那个分支上生成的最后一个提交的指针。
那意味着 HEAD 将会是将要创建出的下一个提交的父结点。
通常最简单理解 HEAD 的方式就是将它认为是 *你的最后一次提交* 的快照。

实际上，查看快照看起来像什么很容易。
这里有一个显示 HEAD 快照的例子，显示实际的目录与每一个文件的 SHA 校验和：

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

`cat-file` 与 `ls-tree` 命令是底层命令，是用于底层事物并不在日常工作中使用，但是它们帮助我们看到这里发生了什么。

[[_the_index]]
===== 索引

索引是你的 *打算的下一个提交*。我们也会将这个概念引用为 Git 的 ``暂存区域''，这就是当你运行 `git commit` 时 Git 看起来的样子。

Git 填充这个索引区为最后一次检出到你工作目录中的所有文件内容，它们看起来像它们最初被检出时的样子。
然后你会替换其中的一些文件为新版本，`git commit` 将那些转换为新提交的树对象。

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

再一次，这里我们使用 `ls-files`，更像是一个幕后的命令，将你的索引现在的样子显示出来。

索引不是一个确切意义上的树结构 -它实际上是以扁平的清单文件实现的 - 但是对于我们的目的而言它足够了。

===== 工作目录

最终，你有你的工作目录。
另外两棵树以一种高效但不方便的方式存储它们的内容，在 `.git` 文件夹中。
工作目录将它们展开为实际的文件，将会使你编辑它们变得很容易。
可以将工作目录想象为 *沙盒*，在你提交修改到你的暂存区，然后提交到历史前，你可以尝试修改。

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== The Workflow
==== 工作流程

Git 的主要目的是以连续更好的状态来记录你的项目的快照，通过操纵这三棵树。

image::images/reset-workflow.png[]

让我们来可视化这个过程：假设你进入到有一个文件的新目录。
我们称这是这个文件的 *v1* 版本，我们标记它为蓝色。
现在我们运行 `git init`，将会创建一个 Git 仓库，有一个 HEAD 引用指向未出生的分支（`master` 还不存在）。

image::images/reset-ex1.png[]

在这时，只有工作目录有内容。

现在我们想要提交这个文件，所以我们使用 `git add` 来拿取工作目录中的内容并拷贝它到索引中。

image::images/reset-ex2.png[]

然后我们运行 `git commit`，将索引中的内容拿走并保存为一个永久的快照，创建指向快照的一个提交对象，并且更新 `master` 来指向那次提交。

image::images/reset-ex3.png[]

如果我们运行 `git status`，我们将会看到没有改动，因为所有三棵树是相同的。

现在我们想要对文件做一个修改并提交它。
我们将会经历同样的过程；首先我们在我们的工作目录中修改文件。
让我们称这个为文件的 *v2* 版本，并标记它为红色。

image::images/reset-ex4.png[]

如果现在我们运行 `git status`，我们将会看到文件显示为红色在 ``Changes not staged for commit,'' 下面因为在索引与工作目录间存在不同。
接下来我们对其运行 `git add` 来暂存它到我们的索引中。

image::images/reset-ex5.png[]

在这时候如果我们运行 `git status` 我们将会看到文件变为绿色
在 ``Changes to be committed'' 下面因为索引与 HEAD 不同 - 那就是说，我们的下一个提交现在与我们的上一个提交不同。
最终，我们运行 `git commit` 来结束提交。

image::images/reset-ex6.png[]

现在 `git status` 将会给我们空输出，因为所有三棵树又是相同的了。

切换分支与克隆会经历类似的过程。
当你检出到一个分支，它修改 *HEAD* 来指向新分支的引用，将你的 *索引* 填充为那次提交的快照，然后拷贝 *索引* 内的内容到你的 *工作目录* 中。

==== 重置的角色

`reset` 命令在这个上下文中更有意义。

为了这些例子的目的，假设我们再一次修改了 `file.txt` 文件然后第三次提交它。所以现在我们的历史看起来像这样：

image::images/reset-start.png[]

让我们看一看在你调用 `reset` 时做了什么。它以一种简单可预见的方式直接操纵这三棵树。
它做了三个基本操作。

===== 第 1 步：移动 HEAD

`reset` 将会做的第一件事是移动 HEAD 的指向。
这与改变 HEAD 自身不同（`checkout` 所做的）；`reset` 移动 HEAD 指向的分支。
这意味着如果 HEAD 设置为 `master` 分支（例如，你正在 `master` 分支上），运行 `git reset 9e5e64a` 将会使 `master` 指向 `9e5e64a`。

image::images/reset-soft.png[]

不论你调用了任何形式的有一个提交的 `reset`，这都是它始将尝试去做的第一件事。
使用 `reset --soft`，它将会只是停在那儿。

现在花费几秒钟看一下那个图表并意识到发生了什么：它本质上取消了上一次 `git commit` 命令。
当你运行 `git commit`，Git 创建一个新提交并将 HEAD 指向的分支移动指向它。
当你 `reset` 回到 `HEAD~`（HEAD 的父结点），你正将分支移动回原来所在的位置，而不改变索引与工作目录。
你可以现在更新索引与再次运行 `git commit` 来完成 `git commit --amend` 将要做的（见 <<_git_amend>>）。

===== 第 2 步：更新索引（--mixed）

注意如果你现在运行 `git status` 你会看到在索引与新的 HEAD 间有绿色的区别。

下一件 `reset` 将要做的是更新索引，使用 HEAD 现在指向快照的内容。

image::images/reset-mixed.png[]

如果你指定 `--mixed` 选项，`reset` 将会在这时停止。
这也是默认行为，所以如果你没有指定任何选项（在本例中只是 `git reset HEAD~`），这就是命令将会停止的地方。

现在再花费几秒钟来看看图表并意识到发生了什么：它还是会取消你的上次 `提交`，但是也会 _取消暂存_ 每一件东西。
你回到了你运行的所有 `git add` 与 `git commit` 命令前。

===== 第 3 步：更新工作目录（--hard）

`reset` 将会做的第三件事情是使工作目录看起来像索引。
如果你使用 `--hard` 选项，它将会继续这一步。

image::images/reset-hard.png[]

现在让我们想想刚才发生的。
你取消了你最后的提交，`git add` 与 `git commit` 命令，**与**所有你在你的工作目录中做的工作。

需要重点注意的是这个标记（`--hard`）是让 `reset` 命令危险的唯一方式，也是 Git 会真正地销毁数据的仅有的几个操作之一。
任何其他形式的 `reset` 调用都可以被相当轻松地撤消，但是 `--hard` 选项不能，因为它强制覆盖了工作目录中的文件。
在这个特别的例子中，在我们的 Git 数据库的一个提交中始终存在我们文件的 *v3* 版本，我们可以通过我们的 `reflog` 来找回，但是如果我们还未提交，Git 还是会覆盖文件并且文件无法恢复。

===== 回顾

`reset` 命令以特定的方式覆盖这三棵树，在你告诉它以下选项时停止：

1. 移动分支 HEAD 指向 _（如果指定 `--soft` 时停止）_
2. 使索引看起来像 HEAD _（不指定 `--hard` 时停止）_
3. 使工作目录看起来像索引

==== 通过一个路径重置

上面讲述了 `reset` 在它基本形式的行为，但是你也可以给它提供一个起作用的路径。
如果你指定一个路径，`reset` 将会跳过第 1 步，并且限制它的动作的范为是一个指定的文件或文件集合。
这实际上有点意儿 - HEAD 只是一个指针，你并不可以部分指向一个提交而另一部分指向另一个提交。
但是索引与工作目录 _可以_ 部分更新，所以重置通过第 2 步与第 3 步进行。

这样，假定我们运行 `git reset file.txt`
这个形式（因为你没有指定一个提交的 SHA 或分支，你不必指定 `--soft` 或 `--hard`）是 `git reset --mixed HEAD file.txt` 的简写形式，将会：

1. 移动分支 HEAD 指向 _（跳过）_
2. 使索引像 HEAD _（在这里停止）_

所以它本质上只是从 HEAD 拷贝 `file.txt` 到索引中。

image::images/reset-path1.png[]

这有 _取消暂存_ 文件的实际效果。
如果我们查看那个命令的图表然后思考 `git add` 所做的，它们就是相反的。

image::images/reset-path2.png[]

这就是为什么 `git status` 命令的输出建议你运行这个来取消暂存一个文件。
（查看 <<_unstaging>> 来了解更多。）

我们可以不让 Git 假定我们 ``从 HEAD 拉取数据''，而是通过指定一个特定的提交来拉取对应的版本。
我们将要只运行类似 `git reset eb43bf file.txt` 的命令。

image::images/reset-path3.png[]

这实际上做了同样的事，即我们将工作目录中的文件恢复到了 *v1* 版本，运行 `git add` 添加它，然后再次恢复它到 *v3* 版本（不用真正地经过所有那些步骤）。
如果现在我们运行 `git commit`，它将会记录一个将文件恢复回 *v1 版本的修改，尽管我们从未真正地在工作目录中再次拥有它。

另一个像 `git add` 的很有趣的事情，`reset` 命令也会接受一个 `--patch` 选项来一块一块地取消暂存内容。
这样你可以选择性的取消暂存与恢复内容。

==== 压缩

让我们看看可以利用这个新力量来如何做一些有趣的事情 - 压缩提交。

假设你有其中的信息像是``oops.''、``WIP'' 与 ``forgot this file'' 的一系列提交。
你可以使用 `reset` 来快照轻松的压缩它们成单个提交来使你显得更聪明。
（<<_squashing>> 展示了这样做的另一种方式，但是本例中用 `reset` 更容易。）

让我们假定你有一个项目第一次提交有一个文件，第二次提交增加了一个新的文件并修改了第一个，第三次提交再一次修改了第一个文件。
第二次提交是一个未完工作因此你想要压缩它。

image::images/reset-squash-r1.png[]

你可以运行 `git reset --soft HEAD~2` 来移动 HEAD 分支到一个旧一些的提交（你想要保留第一个提交）：

image::images/reset-squash-r2.png[]

然后简单地再次运行 `git commit`：

image::images/reset-squash-r3.png[]

现在你可以查看你的可到达的历史，你将会推送的历史，现在看起来你有一个 `file-a.txt` v1 的一个提交，第二个提交修改了 `file-a.txt` 到 v3 并增加了 `file-b.txt`。有 v2 版本的文件的提交已经不在历史中了。

==== 检出

最终，你可能想要知道 `checkout` 与 `reset` 之间的区别是什么。
就像 `reset`，`checkout` 操纵三棵树，它有一点不同依赖于你是否给命令一个文件路径。

===== 没有路径

运行 `git checkout [branch]` 相当类似于运行 `git reset --hard [branch]` 在它为你更新所有三棵树使其看起来像 `[branch]`，但是它们有两个重要区别。

首先，不像 `reset --hard`，`checkout` 是工作目录安全的；它会检查来确保不会将有修改的文件吹走。
实际上，它比那儿更聪明一些 - 它尝试在工作目录中做一个不重要的合并，这样所有你 _没有_ 修改的文件都会被更新。
`reset --hard`，在另一方面，将会没有检查而全面地简单地替换每一个东西。

第二个重要的区别是如何更新 HEAD。
`reset` 将会移动 HEAD 指向的分支的指向，`checkout` 只会移动 HEAD 自身指向另一个分支。

例如，假设我们有 `master` 与 `develop` 分支分别指向不同的提交，我们现在在 `develop`（所以 HEAD 指向它）。
如果我们运行 `git reset master`，`develop` 自身现在会指向 `master` 指向的同一个提交。
如果我们运行 `git checkout master` 替代的话，`develop` 不会移动，HEAD 自身移动了。
HEAD 现在将会指向 `master`。

所以，在两种情况下我们都移动 HEAD 指向提交 A，但是我们 _如何_ 做是非常不同的。
`reset` 将会移动 HEAD 指向分支的指向，`checkout` 移动 HEAD 自身。

image::images/reset-checkout.png[]

===== 有路径

另外运行 `checkout` 的方式是有一个文件路径，像 `reset` 一样，不会移动 HEAD。
它就像 `git reset [branch] file` 那样用那次提交的那个文件来更新索引，但是它也会覆盖工作目录中的那个文件。
它就像是 `git reset --hard [branch] file`（如果 `reset` 允许你那样运行）- 这不是工作目录安全的，它也不会移动 HEAD。

同样，像 `git reset` 与 `git add`，`checkout` 也接受一个 `--patch` 选项允许你选择性的以一块块的形式恢复文件内容。

==== 总结

希望现在你理解并对 `reset` 命令感觉更舒服一些，但是关于它与 `checkout` 的区别可能还会有一点困惑，并且不太可能记住所有不同调用的规则。

这里是一个哪些命令影响哪些树的速查表。
``HEAD'' 列中 ``REF'' 是命令移动 HEAD 指向的分支引用，``HEAD'' 是只移动 HEAD 自身。
特别注意 'WD Safe?' 列 - 如果它说 *NO*，在运行那个命令前考虑一下。

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
