[[_remote_branches]]
=== 远程分支

(((branches, remote)))(((references, remote)))
远程分支是对你远程仓库分支状态的引用（指针）。
它们是你不能移动的本地分支；当你做任何网络通信活动时它们会自动移动。
远程分支像是你上次连接到远程仓库那些分支所处状态的书签。

它们以 `(remote)/(branch)` 形式命名。
例如，如果你想要看最后一次你与远程 `origin` 通信时的 `master` 分支的状态，你可以查看 `origin/master` 分支。
如果你在与同事共同解决一个问题并且他们推送了一个 `iss53` 分支，你可能有你自己的本地 `iss53` 分支；但是在服务器上的分支会指向 `origin/iss53` 的提交。

这看起来有一点难以理解，所以让我们来看一个例子。
让我们假设你的网络里有一个在 `git.ourcompany.com` 的 Git 服务器。
如果你从这里克隆，Git  的 `clone` 命令会为你自动将其命名为 `origin`，拉取所有它的数据，创建一个指向它的 `master` 分支的指针，并且在本地将其命名为 `origin/master`。
Git 也会给你一个与 origin 的 `master` 分支在同一个地方的你本地的 `master` 分支，这样给你一个做事情的源头。

[NOTE]
.``origin'' 并不特别
====
就像是分支名字 ``master'' 在 Git 中并没有任何特别的含义一样，``origin'' 也是。同时 ``master'' 是当你运行 `git init` 时默认的起始分支名字，原因仅仅是因为它被广泛使用了，``origin'' 是当你运行 `git clone` 时默认的远程名字。如果你运行 `git clone -o booyah`，那么你默认的远程分支名字将会是 `booyah/master`。(((origin)))
====

.克隆之后的服务器与本地仓库
image::images/remote-branches-1.png[Server and local repositories after cloning.]

如果你在你本地的 master 分支做一些工作，然而在同一时间，其他人推送提交到 `git.ourcompany.com` 并更新了它的 `master` 分支，那么你的历史向不同的方向前进。
也许，只要你不与你的 origin 服务器连接，你的 `origin/master` 指针就不会移动。

.本地与远程的工作可以分叉
image::images/remote-branches-2.png[Local and remote work can diverge.]

为了同步你的工作，你运行一个 `git fetch origin` 命令。
这个命令查找 ``origin'' 是哪一个服务器（在本例中，它是 `git.ourcompany.com`），从中抓取任何你没有的数据，并且更新你的本地数据库，移动你的 `origin/master` 指针指向新的、更同步的位置。

.`git fetch` 更新你的远程引用
image::images/remote-branches-3.png[`git fetch` updates your remote references.]

为了演示有多个远程服务器与其远程分支的情况，我们假定你有另一个内部 Git 服务器只是被你的 sprint 小组做开发用。
这个服务器位于 `git.team1.ourcompany.com`。
你可以通过运行我们在之后 <<_git_basics_chapter>> 讲到的 `git remote add` 命令添加一个新的远程引用到当前你所在的项目。
将这个远程服务器命名为 `teamone`，将其作为整个 URL 的缩写。

.添加另一个远程服务器
image::images/remote-branches-4.png[Adding another server as a remote.]

现在，你可以运行 `git fetch teamone` 来抓取每一件远程 `teamone` 有而你没有的数据。
因为那台服务器有的是你 `origin` 服务器现在数据的子集，Git 并不会抓取数据然而会设置远程分支 `teamone/master` 指向 `teamone` 的 `master` 分支。

.远程跟踪分支 `teamone/master`
image::images/remote-branches-5.png[Remote tracking branch for `teamone/master`.]

[[_pushing_branches]]
==== 推送

(((pushing)))
当你想要与世界分享一个分支时，你需要将其推送到你有写入权限的远程服务器上。
你本地的分支并不会自动与你的远程服务器同步 - 你必须显式地推送你想要分享的分支。
那样，你可以使用你不想分享的私人分支工作，同时只推送你想要协作的特性分支。

如果你有一个名为 `serverfix` 的分支想要与其他人一同工作，你可以像推送你的第一个分支那样推送它。
运行 `git push (remote) (branch)`:(((git commands, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

这里有一点快捷方式。
Git 自动将 `serverfix` 分支名字展开为 `refs/heads/serverfix:refs/heads/serverfix`，那意味着，``拿我本地的 serverfix 分支然后将其推送来更新远程服务器上的 serverfix 分支。''
我们将会详细学习 <<_git_internals>> 的 `refs/heads/` 部分，但是你现在可以先把它放在儿。
你也可以运行 `git push origin serverfix:serverfix`，会做同样的事 - 那意味着， ``拿我的 serverfix 然后将其做为远程的 serverfix''
你可以通过这种格式来推送一个命名不相同的本地分支到远程分支。
如果你并不想让远程服务器上的分支叫做 `serverfix`，你可以运行 `git push origin serverfix:awesomebranch` 来将你本地的 `serverfix` 分支推送到远程服务器上的 `awesomebranch` 分支。

[NOTE]
.不要每次都输入你的密码
====
如果你正在使用 HTTPS URL 来推送，Git 服务器会询问你的用户名与密码用作验证。默认情况下它会在你的终端中提示你这个信息所以服务器可以告诉你是否被允许推送。

如果你不想在每一次推送时都输入用户名密码，你可以设置一个 ``credential cache''。最简单的方式就是将其保存在内存中几分钟，你可以简单地运行 `git config --global credential.helper cache` 来设置它。

想要了解更多关于不同验证缓存的可用选项，查看 <<_credential_caching>>。
====

下一次一个你的协作者从服务器上抓取时，他们会得到位于远程分支 `origin/serverfix` 上服务器的 `serverfix` 版本的引用。

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

要重要注意一点当你抓取回来新的远程分支时，你并不会自动有其可本地编辑的拷贝。
换一句话说，这种情况下，你不会有一个新的 `serverfix` 分支 - 你只有一个你不可以修改的 `origin/serverfix` 指针。

将这些工作合并到你当前所在的分支，你可以运行 `git merge origin/serverfix`。
如果你想要你自己的可以工作的 `serverfix` 分支，你可以将其建立在你的远程分支之上：

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

这会给你一个本地的可工作的分支，并且起点位于 `origin/serverfix`。

[[_tracking_branches]]
==== 跟踪分支

(((branches, tracking)))(((branches, upstream)))
从一个远程分支检出一个本地分支会自动创建一个叫做 ``跟踪分支''（或者有时也叫做 ``上游分支''）。
跟踪分支是与远程分支有直接关系的本地分支。
如果你在一个跟踪分支上输入 `git pull`，Git 自动地知道该去哪个服务器上抓取与合并到哪个分支。

当你克隆一个仓库时，它通常会自动地创建一个跟踪 `origin/master` 的 `master` 分支。
然而，如果你愿意的话你可以设置其他的跟踪分支 - 其他服务器上的跟踪分支，或不跟踪 `master` 分支。
最简单的就是你之前看到的例子，运行 `git checkout -b [branch] [remotename]/[branch]`。
这是一个足够普遍的操作所以 Git 提供的 `--track` 快捷方式：

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

设置一个本地分支与远程分支不同名字，你可以轻松地使用第一个版本但是不同的本地分支名字：

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

现在，你的本地分支 `sf` 会自动从 `origin/serverfix` 拉取。

如果你已经有一个本地分支并且想要设置其跟踪你拉取的远程分支，或者想要修改你正在跟踪的上游分支，你可以在任意时间使用 `-u` 或 `--set-upstream-to` 选项运行 `git branch` 来显式地设置。

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.上游快捷方式
====
当你已经设置后跟踪分支，你可以通过 `@{upstream}` 或 `@{u}` 快捷方式来引用它。所以当你在 `master` 分支时并且它正在跟踪 `origin/master` 时，如果你愿意的话你可以使用 `git merge @{u}` 来取代 `git merge origin/master`。
====

如果你想要查看所有你设置的跟踪分支，你可以使用 `git branch` 的 `-vv` 选项。这会将你所有的本地分支列出来并且包含更多的信息如每一个分支正在跟踪哪个远程分支与你本地分支是否是领先、落后或是都有。

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

所以这里我们可以看到我们的 `iss53` 分支正在跟踪 `origin/iss53` 并且是 ``ahead'' 是 2，意味着我们本地有两个提交还没有推送到服务器上。我们也能看到我们的 `master` 分支正在跟踪 `origin/master` 分支并且是最新的。接下来我们可以看到我们的 `serverfix` 分支正在跟踪我们 `teamone` 服务器上的 `server-fix-good` 分支并且领先 2 落后 1，意味着服务器上有一次提交我们还没有合并入同时本地有三次提交我们还没有推送。最后我们看到我们的 `testing` 分支并没有跟踪任何远程分支。

需要重点注意的一点是这些数字显示来自于你最后一次从每一个服务器上抓取。这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。如果你想要统计最新的领先与落后数字，你需要在运行此命令前从你所有的远程服务器抓取。你可以像这样做：`$ git fetch --all; git branch -vv`

==== 拉取

(((pulling)))
当 `git fetch` 命令从服务器上抓取所有你没有的数据时，它并不会修改你工作目录中的内容。
它只会为你获取数据然后让你自己合并。
然而，有一个命令叫作 `git pull` 是一个在大多数情况下基本的 `git fetch` 立即跟着一个 `git merge` 命令。
如果你有一个像之前章节中演示的设置好的跟踪分支，不管是显式地设置还是通过 `clone` 或 `checkout` 命令为你创建的，`git pull` 会查找你当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。

由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。

[[_delete_branches]]
==== 删除远程分支

(((branches, deleting remote)))
假设你已经通过远程分支做完所有的工作了 - 也就是说你和你的协作者已经完成了一个特性并且将其合并到了你远程的 `master` 分支（或任何其他你的稳定代码分支）。
你可以删除一个远程分支通过 `--delete` 选项给 `git push`。
如果你想要从服务器上删除你的 `serverfix` 分支，你运行下面的命令：

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

基本上所有这个命令做的只是从服务器上移除这个指针。Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常会很容易恢复。
