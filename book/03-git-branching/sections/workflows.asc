=== 分支工作流程

现在你已经掌握了新建分支与合并分支的基础，该用它能做或应该做什么呢？
这本节中，我们将会了解一些由于轻量级分支功能变得可能的普遍的工作流程，所以你可以决定是否将其整合入你自己的开发流程中。

==== 长期分支

(((branches, long-running)))
因为 Git 使用简单的三方合并，在长时间内多次合并一个分支到另一个分支通常很容易。
这意味着你同时可以有几个分支处于开放状态并且用于开发流程中的不同阶段。你可以定期地合并一个分支到另一个分支。

许多 Git 开发者有一个拥抱了这种变化的工作流程，例如只有一份在他们 `master` 分支的完全稳定的代码 - 可能是唯一一份已经发布或将要发布的代码。
他们有另一个平行的 `develop` 或 `next` 分支用于他们的工作或用来测试稳定性 - 它并不需要总是稳定，但是不论何时它进入到稳定状态，它都可以被合并入 `master` 分支。
它用来拉取准备好的特性分支（短期分支，像你之前的 `iss53` 分支），来保证他们通过了所有测试并且未引入 bugs。

实际上，我们正在讨论关于你制造的提交记录上移动的指针。
稳定的分支在你提交历史的下方，然而前沿分支在提交历史的上方。

.渐进稳定分支的直线图
image::images/lr-branches-1.png[A linear view of progressive-stability branching.]

通常来说把它们想象成流水线更容易理解，当一组提交完全测试后毕业到下一条流水线。

[[lrbranch_b]]
.流水线视角下的渐进稳定分支
image::images/lr-branches-2.png[A ``silo'' view of progressive-stability branching.]

你可以一直保持这样做来维持几个程度的稳定性。
一些大型工程也许会有一个 `proposed` 或 `pu` （proposed updates）分支去整合那些还没有准备好进入 `next` 或 `master` 分支的特性分支。
关键点就是你的分支在不同的稳定性上；当他们到达一个更稳定的状态时，他们被合并到他们上层的分支。
再次，有几个长期分支并不是必要的，但是它们经常很有用，特别是当你在处理非常大型或复杂的项目时。

[[_topic_branch]]
==== 特性分支

(((branches, topic)))
特性分支，然而，在任何大小的项目中都有用。
一个特性分支是你创建用来一个单独特定的功能或相关工作的短期分支。
由于使用之前的 VCS 创建与合并分支的代价通常过高，你可能并没有这么做过。
但是在 Git 中非常容易一天内创建、工作、合并与删除分支几次。

在上一节中你通过你创建的 `iss53` 与 `hotfix` 分支已经看到了这个。
你在它们上面做了几次提交然后在将它们合并到你的主分支后直接删除了它们。
这个技术允许你快速完整地环境切换 - 因为你的工作被分到不同工作流中，在那个分支中所有的修改都必须与那个特性有关，这样在代码审核或其他活动中更容易看到发生了什么。
你可以将修改保留在那几分钟、几天或几个月，然后在它们准备好时合并进来，而不管它们创建或工作时的顺序。

考虑这样做了一些工作（在 `master` 上）的例子，为了一个问题（`iss91`）新建一个分支，在上面做一点事情，再新建第二个分支去尝试处理同一件事的另一种方法（`iss91v2`），然后返回到你的 master 分支在那儿继续工作一会儿，再为你并不确定好不好的想法新建一个分支（`dumbidea` 分支）做一些事情。
你的提交历史会像下面这个样子：

.多个特性分支
image::images/topic-branches-1.png[Multiple topic branches.]

现在，让我们假定你认为第二个解决方案是最好的（`iss91v2`）；你将 `dumbidea` 分支展示给你的同事看，它被认为是天才的想法。
你可以将原来的 `iss91` 分支扔掉了（将会丢失 `C5` 与 `C6` 提交）然后合并其他两个分支。
你的历史看起来像这样：

.合并完 `dumbidea` 与 `iss91v2` 分支后的历史
image::images/topic-branches-2.png[History after merging `dumbidea` and `iss91v2`.]

我们将在 <<_distributed_git>> 详细地讨论适合你的 Git 项目的更多不同的工作流。所以在你决定你的下个项目使用哪种分支模型前，一定去阅读那一章。

要特别记住的是当你做这些事情时所有的分支都是完全的本地分支。
当你新建分支与合并时，每一件事都只在你本地的 Git 仓库中完成 - 没有与服务器发生任何的通信。
